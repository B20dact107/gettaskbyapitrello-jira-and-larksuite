import os
import requests
from requests.auth import HTTPBasicAuth
from telegram import Update, Bot
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
)
from telegram.ext import ConversationHandler, CallbackQueryHandler  
from pymongo import MongoClient
from dotenv import load_dotenv
import asyncio
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from datetime import datetime, timedelta  

load_dotenv()

client = MongoClient(os.getenv("MONGO_URI"))
db= client["task_database"]
tasks_collection = db ["unified_tasks"]
user_credentials = db["user_credentials"]


# Th√™m ph·∫ßn ƒë·ªãnh nghƒ©a state ·ªü ƒë·∫ßu file
(AWAITING_TRELLO_CREDS, AWAITING_JIRA_CREDS,  AWAITING_LARK_CREDS, PLATFORM_SELECTED,AWAITING_TRELLO_BOARD_NAME,
    AWAITING_TRELLO_LIST_NAME,
    AWAITING_JIRA_PROJECT_KEY, AWAITING_LARK_TASKLIST_NAME) = range(5, 13)  

TOKEN = os.getenv("TELEGRAM_TOKEN")

async def check_trello_auth(user_id: int) -> bool:
    creds = user_credentials.find_one({
        "user_id": user_id,
        "platform": "trello"
    })
    return creds is not None and "default_board" in creds and "default_list" in creds

async def create_issue(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = user_credentials.find_one({"chat_id": update.message.chat_id})
    if not user:
        await update.message.reply_text("‚ùå Vui l√≤ng d√πng /start tr∆∞·ªõc!")
        return ConversationHandler.END
    
    if not await check_trello_auth(user["user_id"]):
        await update.message.reply_text(
            "‚ö†Ô∏è Vui l√≤ng k·∫øt n·ªëi Trello tr∆∞·ªõc!\n"
            "D√πng l·ªánh /connect v√† ch·ªçn Trello ƒë·ªÉ k·∫øt n·ªëi"
        )
        return ConversationHandler.END
    
    await update.message.reply_text("üìù H√£y nh·∫≠p ti√™u ƒë·ªÅ task:")
    return DESCRIPTION


async def handle_trello_credentials(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        parts = update.message.text.split(":")
        if len(parts) != 4:
            raise ValueError("Sai ƒë·ªãnh d·∫°ng")
            
        api_key, token, board_id, list_id = parts
        
        user_credentials.update_one(
            {"user_id": update.message.from_user.id, "platform": "trello"},
            {"$set": {
                "api_key": api_key,
                "token": token,
                "default_board": board_id,
                "default_list": list_id,
                "connected_at": datetime.now()
            }},
            upsert=True
        )
        
        await update.message.reply_text("‚úÖ K·∫øt n·ªëi Trello th√†nh c√¥ng!")
        return ConversationHandler.END
    except Exception as e:
        await update.message.reply_text(f"‚ùå L·ªói: {str(e)}")
        return ConversationHandler.END
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‚ùå ƒê√£ h·ªßy thao t√°c!")
    context.user_data.clear()
    return ConversationHandler.END

# (
#     PLATFORM_SELECTED,
#     AWAITING_TRELLO_BOARD_NAME,
#     AWAITING_TRELLO_LIST_NAME,
#     AWAITING_JIRA_PROJECT_KEY
# ) = range(4, 8)  


async def handle_platform_connect(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()  
    platform = query.data.split("_")[1]
    
    if platform == "trello":
        return await handle_trello_connection(update, context)
    elif platform == "jira":
        return await handle_jira_connection(update, context)
    elif platform == "lark":
        return await handle_lark_connection(update, context)
    else:
        await query.answer("N·ªÅn t·∫£ng kh√¥ng h·ªó tr·ª£!")
        return ConversationHandler.END

async def start(update : Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.message.from_user
    # L∆∞u th√¥ng tin ng∆∞·ªùi d√πng v√†o collection 'users'
    db.user_credentials.update_one(
        {"user_id": user.id},
        {"$set": {
            "username": user.username,
            "chat_id": update.message.chat_id
        }},
        upsert=True
    )
    await update.message.reply_text(
        "üëã Ch√†o m·ª´ng ƒë·∫øn v·ªõi Assistant AI Bot!\n"
        "C√°c l·ªánh h·ªó tr·ª£:\n"
        "/start - H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng\n"
        "/username - Thi·∫øt l·∫≠p username ƒë·ªÉ c√≥ th·ªÉ l·∫•y ra danh s√°ch task\n"  
        "/connect - K·∫øt n·ªëi v·ªõi Trello, Jira, Larksuite\n" 
        "/tasks - Hi·ªÉn th·ªã danh s√°ch task (d√πng user_id n·∫øu cung c·∫•p, "
        "n·∫øu kh√¥ng th√¨ d√πng chat_id)\n"
        "/create_issue [n·ªôi dung] - T·∫°o task m·ªõi\n"
        "‚ö†Ô∏è C·∫£nh b√°o t·ª± ƒë·ªông s·∫Ω ƒë∆∞·ª£c g·ª≠i khi task s·∫Øp h·∫øt h·∫°n!"
    )
async def username(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.args:
        await update.message.reply_text("‚ö†Ô∏è Vui l√≤ng nh·∫≠p username (v√≠ d·ª•: /username sui00002002)")
        return
    
    new_username = context.args[0]
    user = update.message.from_user
    
    user_credentials.update_one(
        {"user_id": user.id},
        {"$set": {"username": new_username}},
        upsert=True
    )
    
    await update.message.reply_text(f"‚úÖ ƒê√£ c·∫≠p nh·∫≠t username th√†nh: {new_username}")
async def show_tasks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = user_credentials.find_one({"chat_id": update.message.chat_id})
    
    if not user:
        await update.message.reply_text("‚ùå Vui l√≤ng d√πng /start tr∆∞·ªõc!")
        return
    
    # T√¨m c√°c task li√™n quan
    tasks = tasks_collection.find({
        "$or": [
            {"members": user["username"]},
            {"assignees": user["username"]}
        ]
    }, {"_id": 0})
    
    if not tasks:
        await update.message.reply_text("üì≠ B·∫°n kh√¥ng c√≥ task n√†o!")
        return
    
    response = "üìã Danh s√°ch task c·ªßa b·∫°n:\n"
    for task in tasks:
        response += f"- {task['title']} (Deadline: {task['due_date']})\n"
    await update.message.reply_text(response)

TITLE, DESCRIPTION, PRIORITY, ASSIGNEES, PLATFORM = range(5)

async def create_issue(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üìù H√£y nh·∫≠p ti√™u ƒë·ªÅ task:")
    return TITLE

async def get_title(update: Update , context: ContextTypes.DEFAULT_TYPE):
    context.user_data['title'] = update.message.text  
    await update.message.reply_text("üìÑ Nh·∫≠p m√¥ t·∫£ task:")
    return DESCRIPTION

async def get_description(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['description'] = update.message.text
    await update.message.reply_text("üîù Ch·ªçn ƒë·ªô ∆∞u ti√™n (low/medium/high")
    return PRIORITY

async def get_priority(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['priority'] = update.message.text
    await update.message.reply_text("üë• Nh·∫≠p user_name assignees (c√°ch nhau b·∫±ng d·∫•u ph·∫©y):")
    return ASSIGNEES

async def get_assignees(update: Update, context: ContextTypes.DEFAULT_TYPE):
    assignees = [name.strip() for name in update.message.text.split(",")]
    context.user_data['assignees'] = assignees
    await update.message.reply_text("üåê Nh·∫≠p n·ªÅn t·∫£ng (trello, jira, lark):")
    return PLATFORM

async def get_platform(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['platform'] = update.message.text.strip().lower()
    
    try:
        # G·ªçi h√†m x·ª≠ l√Ω cu·ªëi c√πng
        await finalize_task(update, context)
        return ConversationHandler.END
    except Exception as e:
        await update.message.reply_text(f"‚ùå L·ªói: {str(e)}")
        return ConversationHandler.END
async def create_task_on_platform(platform: str, task_data: dict):
    if platform == "trello":
        try:
            # L·∫•y th√¥ng tin x√°c th·ª±c t·ª´ database
            creds = user_credentials.find_one({
                "user_id": task_data["user_id"],
                "platform": "trello"
            })
            
            if not creds:
                raise Exception("Ch∆∞a k·∫øt n·ªëi Trello! Vui l√≤ng d√πng l·ªánh /connect tr∆∞·ªõc")
            # L·∫•y member IDs t·ª´ Trello
            member_ids = []
            for username in task_data.get("assignees", []):
                # G·ªçi API ƒë·ªÉ l·∫•y th√¥ng tin th√†nh vi√™n
                members_url = f"https://api.trello.com/1/boards/{creds['default_board']}/members"
                params = {
                    'key': creds['api_key'],
                    'token': creds['token'],
                    'filter': 'all'
                }
                response = requests.get(members_url, params=params)
                
                if response.status_code == 200:
                    for member in response.json():
                        if member['username'] == username:
                            member_ids.append(member['id'])
                            break

                
            # Chu·∫©n b·ªã API endpoint v√† params
            url = "https://api.trello.com/1/cards"
            query = {
                'key': creds["api_key"],
                'token': creds["token"],
                'idList': creds["default_list"],
                'name': task_data["title"],
                'description': task_data.get("description", ""),
                'due': task_data.get("due_date"),
                'idMembers': ",".join(member_ids) if member_ids else "",
                'pos': 'top'
            }
            # G·ªçi API Trello
            response = requests.post(
                url,
                params=query,
                timeout=10
            )
            
            if response.status_code != 200:
                raise Exception(f"L·ªói Trello ({response.status_code}): {response.text}")
                
            card_id = response.json()["id"]
            return card_id
            
        except Exception as e:
            raise Exception(f"Kh√¥ng th·ªÉ t·∫°o task tr√™n Trello: {str(e)}")
        
    
    if platform == "jira":
        try:
            creds = user_credentials.find_one({
                "user_id": task_data["user_id"],
                "platform": "jira"
            })
            if not creds or not all([
                creds["jira_domain"],
                creds["jira_email"],
                creds["jira_api_token"],
                creds["project_key"]
            ]):
                raise Exception("Thi·∫øu c·∫•u h√¨nh Jira trong database!")
            
            url = f"https://{creds['jira_domain']}/rest/api/3/issue"

            adf_description = convert_text_to_adf(task_data.get("description", ""))
            username_input = task_data.get("assignees", [""])[0]
            if not username_input:
                account_id = None
            else:
                account_id = get_jira_account_id_from_username(username_input)
        
            
            # Chu·∫©n b·ªã payload
            payload = {
                "fields": {
                    "project": {"key": creds["project_key"]},
                    "issuetype": {"name": "Task"},  
                    "summary": task_data["title"],
                    "description": adf_description,
                    "assignee": {"accountId": account_id} if account_id else None
                    
                }
            }
           
            # G·ªçi API Jira
            response = requests.post(
                url,
                auth=HTTPBasicAuth(creds["jira_email"], creds["jira_api_token"]),
                headers={"Accept": "application/json", "Content-Type": "application/json"},
                json=payload,
                timeout=10
            )
            
            
            if response.status_code == 201:
                return response.json().get("id")
            else:
                raise Exception(f"Jira API Error ({response.status_code}): {response.text}")
        
        except Exception as e:
            raise Exception(f"Kh√¥ng th·ªÉ t·∫°o task tr√™n Jira: {str(e)}")
        
    
    
    elif platform == "lark":
        try:
            # L·∫•y access token t·ª´ DB b·∫±ng c√°ch truy·ªÅn user_id t·ª´ task_data
            access_token = get_lark_access_token(task_data["user_id"])
        # G·ªçi API t·∫°o task
            creds = user_credentials.find_one({
                "user_id": task_data["user_id"], 
                "platform": "lark"
            })
            
            if not creds or "default_tasklist" not in creds:
                raise Exception("Ch∆∞a ch·ªçn task list tr√™n Lark!")
            
            url = "https://open.larksuite.com/open-apis/task/v2/tasks"
            headers = {
                "Authorization": f"Bearer {access_token}",
                "Content-Type": "application/json"
            }
            members = []
            for username in task_data.get("assignees", []):
                user = user_credentials.find_one({"username": username})
                if user:
                    members.append({"id": str(user["user_id"])})
            tasklist_guid = creds["default_tasklist"]
            payload = {
                "summary": task_data["title"].strip(),
                "description": task_data.get("description", ""),
                "due": {
                    "timestamp": int((datetime.fromisoformat(task_data["due_date"])).timestamp() * 1000),
                    "is_all_day": False  # ƒêi·ªÅu ch·ªânh n·∫øu c·∫ßn
                },
                "tasklists": [
                    {"tasklist_guid": tasklist_guid}
                ]
            }

            response = requests.post(url, headers=headers, json=payload)

            if response.status_code != 200:
                raise Exception(f"L·ªói Lark API: {response.text}")

            return response.json()["data"]["task"]["guid"]
            
        except Exception as e:
            raise Exception(f"L·ªói t·∫°o task tr√™n Lark: {str(e)}")

def get_jira_account_id_from_username(username: str) -> str:
    url = f"https://{os.getenv('JIRA_DOMAIN')}/rest/api/3/user/search"
    auth = HTTPBasicAuth(os.getenv("JIRA_EMAIL"), os.getenv("JIRA_API_TOKEN"))
    params = {"query": username}
    response = requests.get(url, params=params, auth=auth, headers={"Accept": "application/json"})

    if response.status_code != 200 or not response.json():
        raise Exception(f"Kh√¥ng t√¨m th·∫•y user v·ªõi username {username}")
    
    # Gi·∫£ s·ª≠ k·∫øt qu·∫£ ƒë·∫ßu ti√™n ch√≠nh l√† user c·∫ßn l·∫•y
    account_id =response.json()[0]["accountId"]
    return response.json()[0]["accountId"]

        
async def finalize_task(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        # L·∫•y th√¥ng tin t·ª´ context
        platform = context.user_data.get("platform", "").lower()
        user = user_credentials.find_one({"chat_id": update.message.chat_id})
        if not user:
            await update.message.reply_text("‚ùå Vui l√≤ng d√πng /start tr∆∞·ªõc!")
            return
        current_username = update.message.from_user.username
        if user.get("username") != current_username:
            user_credentials.update_one(
                {"user_id": user["user_id"]},
                {"$set": {"username": current_username}}
            )
        
        # Chu·∫©n b·ªã d·ªØ li·ªáu task
        task_data = {
            "user_id": user["user_id"],
            "title": context.user_data.get("title", ""),
            "description": context.user_data.get("description", ""),
            "priority": context.user_data.get("priority", "medium").lower(),
            "assignees": context.user_data.get("assignees", []),
            "due_date": datetime.utcnow().isoformat(), 
            "status": "todo",
            "source_platform": platform
        }
        
     
        platform_id = await create_task_on_platform(platform, task_data)
        
        task_record = {
            **task_data,
            "id": f"{platform}:{platform_id}",
            "extend": {
                "labels": [],
                "project": os.getenv("JIRA_PROJECT_KEY") if platform == "jira" else None
            }
        }
        tasks_collection.insert_one(task_record)
        
        await update.message.reply_text(f"‚úÖ ƒê√£ t·∫°o task tr√™n {platform}!")
    
    except Exception as e:
        await update.message.reply_text(f"‚ùå L·ªói: {str(e)}")

async def check_deadlines():
    now = datetime.now()
    three_days_later = now + timedelta(days=3)
    
    tasks = tasks_collection.find({
        "due_date": {"$lte": three_days_later.isoformat()},
        "status": {"$ne": "done"}
    })
    
    for task in tasks:
        assignees = task.get("assignees", [])
        
        for username in assignees:
            user = user_credentials.find_one({"username": username})
            
            if user and user.get("active", True):
                await send_alert(user["chat_id"], task)

async def send_alert(chat_id: int, task: dict):
    status = task.get("status") or task.get("list_name")
    try:
        await Bot(token=TOKEN).send_message(
            chat_id=chat_id,
            text=f"‚ö†Ô∏è S·∫ÆP H·∫æT H·∫†N: {task['title']}\n"
                 f"üìÖ Deadline: {task['due_date']}\n"
                 f"üìå Tr·∫°ng th√°i: {status.upper()}"
        )
    except Exception as e:
        print(f"Kh√¥ng g·ª≠i ƒë∆∞·ª£c c·∫£nh b√°o ƒë·∫øn {chat_id}: {str(e)}")


async def connect_platform(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "üîó Vui l√≤ng nh·∫≠p t√™n n·ªÅn t·∫£ng b·∫°n mu·ªën k·∫øt n·ªëi (trello, jira, lark):"
    )
    return PLATFORM_SELECTED  # state ƒë·ªÉ nh·∫≠n input t·ª´ ng∆∞·ªùi d√πng

async def handle_platform_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    platform = update.message.text.strip().lower()
    if platform not in ["trello", "jira", "lark"]:
        await update.message.reply_text(
            "‚ùå N·ªÅn t·∫£ng kh√¥ng h·ª£p l·ªá, vui l√≤ng nh·∫≠p l·∫°i (trello, jira, lark):"
        )
        return PLATFORM_SELECTED
    if platform == "trello":
        return await handle_trello_connection(update, context)
    elif platform == "jira":
        return await handle_jira_connection(update, context)
    elif platform == "lark":
        return await handle_lark_connection(update, context)
    else:
        await update.message.reply_text("‚ùå N·ªÅn t·∫£ng kh√¥ng h·ªó tr·ª£!")
        return ConversationHandler.END
def convert_text_to_adf(text: str) -> dict:
    """Chuy·ªÉn ƒë·ªïi plain text sang Atlassian Document Format"""
    return {
        "type": "doc",
        "version": 1,
        "content": [
            {
                "type": "paragraph",
                "content": [
                    {
                        "type": "text",
                        "text": text
                    }
                ]
            }
        ]
    }

# s·ª≠a l·∫°i nh·∫≠p list name v·ªõi board name v·ªõi trello
async def handle_trello_connection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """X·ª≠ l√Ω k·∫øt n·ªëi Trello: Y√™u c·∫ßu nh·∫≠p t√™n Board v√† List"""
    await update.message.reply_text("üìã Nh·∫≠p t√™n **Board** Trello c·ªßa b·∫°n:")
    return AWAITING_TRELLO_BOARD_NAME

async def get_trello_board_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """L∆∞u t√™n Board v√† y√™u c·∫ßu nh·∫≠p t√™n List"""
    context.user_data['trello_board'] = update.message.text
    await update.message.reply_text("üìù Nh·∫≠p t√™n **List** trong Board:")
    return AWAITING_TRELLO_LIST_NAME

async def get_trello_list_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """X·ª≠ l√Ω t√™n List v√† l∆∞u Board/List ID v√†o database"""
    try:
        board_name = context.user_data['trello_board']
        list_name = update.message.text

        # L·∫•y Board ID t·ª´ t√™n Board
        boards_url = "https://api.trello.com/1/members/me/boards"
        params = {
            'key': os.getenv("TRELLO_API_KEY"),
            'token': os.getenv("TRELLO_API_TOKEN")
        }
        response = requests.get(boards_url, params=params)
        board_id = next((b['id'] for b in response.json() if b['name'].lower() == board_name.lower()), None)

        if not board_id:
            raise Exception("Kh√¥ng t√¨m th·∫•y Board!")

        # L·∫•y List ID t·ª´ t√™n List
        lists_url = f"https://api.trello.com/1/boards/{board_id}/lists"
        response = requests.get(lists_url, params=params)
        list_id = next((l['id'] for l in response.json() if l['name'].lower() == list_name.lower()), None)

        if not list_id:
            raise Exception("Kh√¥ng t√¨m th·∫•y List!")

        # L∆∞u v√†o database
        user_credentials.update_one(
            {"user_id": update.effective_user.id, "platform": "trello"},
            {"$set": {
                "api_key": os.getenv("TRELLO_API_KEY"),
                "token": os.getenv("TRELLO_API_TOKEN"),
                "default_board": board_id,
                "default_list": list_id,
                "connected_at": datetime.now()
            }},
            upsert=True
        )

        await update.message.reply_text("‚úÖ K·∫øt n·ªëi Trello th√†nh c√¥ng!")
        return ConversationHandler.END

    except Exception as e:
        await update.message.reply_text(f"‚ùå L·ªói: {str(e)}")
        return ConversationHandler.END
#jira
async def handle_jira_connection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """X·ª≠ l√Ω k·∫øt n·ªëi Jira: Y√™u c·∫ßu nh·∫≠p Project Key"""
    await update.message.reply_text("üîë Nh·∫≠p **Project Key** c·ªßa Jira (v√≠ d·ª•: VCC):")
    return AWAITING_JIRA_PROJECT_KEY

async def get_jira_project_key(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """L∆∞u Project Key v√†o database"""
    project_key = update.message.text.upper()
    user_credentials.update_one(
        {"user_id": update.effective_user.id, "platform": "jira"},
        {"$set": {
            "project_key": project_key,
            "jira_email" :os.getenv("JIRA_EMAIL"),
            "jira_domain":os.getenv("JIRA_DOMAIN"),
            "jira_api_token": os.getenv("JIRA_API_TOKEN")
            }},
        upsert=True
    )
    await update.message.reply_text("‚úÖ K·∫øt n·ªëi Jira th√†nh c√¥ng!")
    return ConversationHandler.END
#larksuite
async def handle_lark_connection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """T·ª± ƒë·ªông k·∫øt n·ªëi LarkSuite b·∫±ng th√¥ng tin t·ª´ .env"""
    user_id = update.effective_user.id
    
    app_id = os.getenv("LARKSUITE_APP_ID")
    app_secret = os.getenv("LARKSUITE_APP_SECRET")
    larkurl = os.getenv("LARKSUITE_OAUTH_AUTHORIZE_URL")
    lark_redirect_uri = 'http://127.0.0.1:5000/oauth/callback'
    
    oauth_url = (
         f"https://open.larksuite.com/open-apis/authen/v1/index?"
         f"app_id={app_id}&"
         f"redirect_uri={lark_redirect_uri}"
    )
    await update.message.reply_text(
        "üîë Vui l√≤ng truy c·∫≠p URL sau ƒë·ªÉ c·∫•p quy·ªÅn cho ·ª©ng d·ª•ng:\n"
        f"{oauth_url}\n\n"
        "Sau khi ƒë·ªìng √Ω, h√£y nh·∫≠p CODE b·∫°n nh·∫≠n ƒë∆∞·ª£c t·ª´ trang x√°c th·ª±c."
    )
    return AWAITING_LARK_CREDS

async def handle_lark_authorization_code(update: Update, context: ContextTypes.DEFAULT_TYPE):
    code = update.message.text.strip()
    user_id = update.effective_user.id
    
    try:
        # G·ªçi API ƒë·ªÉ l·∫•y access token
        token_url = "https://open.larksuite.com/open-apis/authen/v1/access_token"
        headers = {"Content-Type": "application/json"}
        payload = {
            "grant_type": "authorization_code",
            "code": code,
            "app_id": os.getenv("LARKSUITE_APP_ID"),
            "app_secret": os.getenv("LARKSUITE_APP_SECRET")
        }
        
        response = requests.post(token_url, json=payload, headers=headers)
        response_data = response.json()
        
        if response_data.get("code") != 0:
            raise Exception(f"L·ªói Lark API: {response_data.get('msg')}")
            
        # L∆∞u th√¥ng tin token v√†o database
        user_credentials.update_one(
            {"user_id": user_id, "platform": "lark"},
            {"$set": {
                "access_token": response_data["data"]["access_token"],
                "refresh_token": response_data["data"]["refresh_token"],
                "expires_in": response_data["data"]["expires_in"],
                "connected_at": datetime.now()
            }},
            upsert=True
        )
        
        await update.message.reply_text("üìã Nh·∫≠p T√äN TASK LIST ch√≠nh x√°c tr√™n Lark:")
        return AWAITING_LARK_TASKLIST_NAME  
        
    except Exception as e:
        await update.message.reply_text(f"‚ùå L·ªói: {str(e)}")
        return ConversationHandler.END
async def handle_lark_tasklist_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        tasklist_name = update.message.text.strip()
        user_id = update.effective_user.id
        
        # L·∫•y access token t·ª´ DB
        access_token = get_lark_access_token(user_id)
        
        # G·ªçi API t√¨m ki·∫øm task list
        url = "https://open.larksuite.com/open-apis/task/v2/tasklists"
        headers = {"Authorization": f"Bearer {access_token}"}
        
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        
        tasklist = next(
            (tl for tl in response.json()["data"]["items"] if tl["name"].lower() == tasklist_name.lower()),
            None
        )
        
        if not tasklist:
            raise Exception(f"Kh√¥ng t√¨m th·∫•y task list v·ªõi t√™n '{tasklist_name}'")
        
        user_credentials.update_one(
            {"user_id": user_id, "platform": "lark"},
            {"$set": {"default_tasklist": tasklist["guid"]}}
        )
        
        await update.message.reply_text(f"‚úÖ ƒê√£ ch·ªçn task list '{tasklist_name}' th√†nh c√¥ng!")
        return ConversationHandler.END

    except Exception as e:
        await update.message.reply_text(f"‚ùå L·ªói: {str(e)}")
        return ConversationHandler.END
def get_lark_access_token(user_id: int):
    """L·∫•y access token t·ª´ database v√† t·ª± ƒë·ªông renew n·∫øu h·∫øt h·∫°n"""
    creds = user_credentials.find_one({"user_id": user_id, "platform": "lark"})
    
    if not creds:
        raise Exception("Ch∆∞a k·∫øt n·ªëi LarkSuite. D√πng l·ªánh /connect lark ƒë·ªÉ k·∫øt n·ªëi")
    
    # Ki·ªÉm tra th·ªùi h·∫°n token
    expires_at = creds["connected_at"] + timedelta(seconds=creds["expires_in"] - 300)  # Tr·ª´ 5p ƒë·ªÉ ƒë·ªÅ ph√≤ng
    if datetime.now() < expires_at:
        return creds["access_token"]
    
    # T·ª± ƒë·ªông renew token n·∫øu h·∫øt h·∫°n
    print("üîÑ Token h·∫øt h·∫°n, ƒëang renew...")
    refresh_url = "https://open.larksuite.com/open-apis/authen/v1/refresh_access_token"
    headers = {"Content-Type": "application/json"}
    payload = {
        "grant_type": "refresh_token",
        "refresh_token": creds["refresh_token"],
        "app_id": os.getenv("LARKSUITE_APP_ID"),
        "app_secret": os.getenv("LARKSUITE_APP_SECRET")
    }
    
    response = requests.post(refresh_url, json=payload, headers=headers)
    refresh_data = response.json()
    
    if refresh_data.get("code") != 0:
        raise Exception(f"L·ªói renew token: {refresh_data.get('msg')}")
    
    # C·∫≠p nh·∫≠t database
    user_credentials.update_one(
        {"_id": creds["_id"]},
        {"$set": {
            "access_token": refresh_data["data"]["access_token"],
            "refresh_token": refresh_data["data"]["refresh_token"],
            "expires_in": refresh_data["data"]["expires_in"],
            "connected_at": datetime.now()
        }}
    )
    
    return refresh_data["data"]["access_token"]
    
def start_scheduler(loop):
    #loop = asyncio.get_event_loop() 
    scheduler = AsyncIOScheduler(event_loop=loop)
    scheduler.add_job(check_deadlines, CronTrigger(hour=9, minute=0))  # Ch·∫°y h√†ng ng√†y l√∫c 9h
    scheduler.start()